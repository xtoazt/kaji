import { Router, Request, Response } from 'express';
import { db } from '../../database/connection';
import { aiService } from '../../services/aiService';
import { asyncHandler, createError } from '../middleware/errorHandler';
import { logger } from '../../utils/logger';
import { CreateExploitRequest, UpdateExploitRequest } from '../../types';

const router = Router();

// Get all exploits with filtering and pagination
router.get('/', asyncHandler(async (req: Request, res: Response) => {
  const {
    page = 1,
    limit = 20,
    severity,
    chromeos_version,
    category,
    search,
    verified_only = false
  } = req.query;

  const offset = (Number(page) - 1) * Number(limit);
  let whereConditions = ['e.is_public = true'];
  const queryParams: any[] = [];
  let paramIndex = 1;

  if (severity) {
    whereConditions.push(`e.severity = $${paramIndex}`);
    queryParams.push(severity);
    paramIndex++;
  }

  if (chromeos_version) {
    whereConditions.push(`e.chromeos_version_id = $${paramIndex}`);
    queryParams.push(chromeos_version);
    paramIndex++;
  }

  if (category) {
    whereConditions.push(`e.category_id = $${paramIndex}`);
    queryParams.push(category);
    paramIndex++;
  }

  if (search) {
    whereConditions.push(`(e.title ILIKE $${paramIndex} OR e.description ILIKE $${paramIndex})`);
    queryParams.push(`%${search}%`);
    paramIndex++;
  }

  if (verified_only === 'true') {
    whereConditions.push('e.is_verified = true');
  }

  const whereClause = whereConditions.length > 0 ? `WHERE ${whereConditions.join(' AND ')}` : '';

  const query = `
    SELECT 
      e.*,
      cv.version as chromeos_version,
      vc.name as category_name,
      u.username as created_by_username
    FROM exploits e
    LEFT JOIN chromeos_versions cv ON e.chromeos_version_id = cv.id
    LEFT JOIN vulnerability_categories vc ON e.category_id = vc.id
    LEFT JOIN users u ON e.created_by = u.id
    ${whereClause}
    ORDER BY e.discovered_date DESC, e.created_at DESC
    LIMIT $${paramIndex} OFFSET $${paramIndex + 1}
  `;

  queryParams.push(Number(limit), offset);

  const result = await db.query(query, queryParams);

  // Get total count
  const countQuery = `
    SELECT COUNT(*) as total
    FROM exploits e
    ${whereClause}
  `;
  const countResult = await db.query(countQuery, queryParams.slice(0, -2));

  res.json({
    exploits: result.rows,
    pagination: {
      page: Number(page),
      limit: Number(limit),
      total: parseInt(countResult.rows[0].total),
      pages: Math.ceil(parseInt(countResult.rows[0].total) / Number(limit))
    }
  });
}));

// Get exploit by ID
router.get('/:id', asyncHandler(async (req: Request, res: Response) => {
  const { id } = req.params;

  const query = `
    SELECT 
      e.*,
      cv.version as chromeos_version,
      vc.name as category_name,
      u.username as created_by_username
    FROM exploits e
    LEFT JOIN chromeos_versions cv ON e.chromeos_version_id = cv.id
    LEFT JOIN vulnerability_categories vc ON e.category_id = vc.id
    LEFT JOIN users u ON e.created_by = u.id
    WHERE e.id = $1
  `;

  const result = await db.query(query, [id]);

  if (result.rows.length === 0) {
    throw createError('Exploit not found', 404);
  }

  res.json(result.rows[0]);
}));

// Create new exploit
router.post('/', asyncHandler(async (req: Request, res: Response) => {
  const exploitData: CreateExploitRequest = req.body;

  // Validate required fields
  if (!exploitData.title || !exploitData.description || !exploitData.chromeos_version_id) {
    throw createError('Title, description, and ChromeOS version are required', 400);
  }

  const query = `
    INSERT INTO exploits (
      cve_id, title, description, severity, cvss_score, category_id,
      chromeos_version_id, discovered_date, disclosed_date, patched_date,
      exploit_code, proof_of_concept, references, tags, is_public, created_by
    ) VALUES (
      $1, $2, $3, $4, $5, $6, $7, $8, $9, $10, $11, $12, $13, $14, $15, $16
    ) RETURNING *
  `;

  const values = [
    exploitData.cve_id || null,
    exploitData.title,
    exploitData.description,
    exploitData.severity,
    exploitData.cvss_score || null,
    exploitData.category_id || null,
    exploitData.chromeos_version_id,
    exploitData.discovered_date || null,
    exploitData.disclosed_date || null,
    exploitData.patched_date || null,
    exploitData.exploit_code || null,
    exploitData.proof_of_concept || null,
    exploitData.references ? JSON.stringify(exploitData.references) : null,
    exploitData.tags || null,
    exploitData.is_public !== false,
    req.user?.id || null
  ];

  const result = await db.query(query, values);

  logger.info('New exploit created', {
    exploitId: result.rows[0].id,
    title: exploitData.title,
    severity: exploitData.severity,
    createdBy: req.user?.id
  });

  res.status(201).json(result.rows[0]);
}));

// Update exploit
router.put('/:id', asyncHandler(async (req: Request, res: Response) => {
  const { id } = req.params;
  const updateData: UpdateExploitRequest = req.body;

  // Build dynamic update query
  const updateFields: string[] = [];
  const values: any[] = [];
  let paramIndex = 1;

  Object.keys(updateData).forEach(key => {
    if (key !== 'id' && updateData[key] !== undefined) {
      updateFields.push(`${key} = $${paramIndex}`);
      values.push(updateData[key]);
      paramIndex++;
    }
  });

  if (updateFields.length === 0) {
    throw createError('No fields to update', 400);
  }

  updateFields.push(`updated_at = CURRENT_TIMESTAMP`);
  values.push(id);

  const query = `
    UPDATE exploits 
    SET ${updateFields.join(', ')}
    WHERE id = $${paramIndex}
    RETURNING *
  `;

  const result = await db.query(query, values);

  if (result.rows.length === 0) {
    throw createError('Exploit not found', 404);
  }

  logger.info('Exploit updated', {
    exploitId: id,
    updatedFields: Object.keys(updateData).filter(k => k !== 'id'),
    updatedBy: req.user?.id
  });

  res.json(result.rows[0]);
}));

// Delete exploit
router.delete('/:id', asyncHandler(async (req: Request, res: Response) => {
  const { id } = req.params;

  const query = 'DELETE FROM exploits WHERE id = $1 RETURNING *';
  const result = await db.query(query, [id]);

  if (result.rows.length === 0) {
    throw createError('Exploit not found', 404);
  }

  logger.info('Exploit deleted', {
    exploitId: id,
    deletedBy: req.user?.id
  });

  res.status(204).send();
}));

// AI-powered exploit analysis
router.post('/:id/analyze', asyncHandler(async (req: Request, res: Response) => {
  const { id } = req.params;

  // Get exploit data
  const exploitQuery = `
    SELECT e.*, cv.version as chromeos_version
    FROM exploits e
    LEFT JOIN chromeos_versions cv ON e.chromeos_version_id = cv.id
    WHERE e.id = $1
  `;

  const exploitResult = await db.query(exploitQuery, [id]);

  if (exploitResult.rows.length === 0) {
    throw createError('Exploit not found', 404);
  }

  const exploit = exploitResult.rows[0];

  // Perform AI analysis
  const analysis = await aiService.analyzeExploit(
    JSON.stringify(exploit),
    exploit.chromeos_version
  );

  // Store analysis in training data
  const trainingDataQuery = `
    INSERT INTO ai_training_data (
      exploit_id, training_prompt, ai_response, model_version, confidence_score
    ) VALUES ($1, $2, $3, $4, $5)
    RETURNING *
  `;

  const trainingPrompt = `Analyze this ChromeOS exploit: ${exploit.title}`;
  const aiResponse = JSON.stringify(analysis);

  await db.query(trainingDataQuery, [
    id,
    trainingPrompt,
    aiResponse,
    'gpt-4o',
    analysis.confidence
  ]);

  res.json({
    exploit_id: id,
    analysis,
    timestamp: new Date().toISOString()
  });
}));

// Get vulnerability statistics
router.get('/stats/overview', asyncHandler(async (req: Request, res: Response) => {
  const statsQuery = `
    SELECT 
      COUNT(*) as total_exploits,
      COUNT(CASE WHEN severity = 'critical' THEN 1 END) as critical_count,
      COUNT(CASE WHEN severity = 'high' THEN 1 END) as high_count,
      COUNT(CASE WHEN severity = 'medium' THEN 1 END) as medium_count,
      COUNT(CASE WHEN severity = 'low' THEN 1 END) as low_count,
      COUNT(CASE WHEN is_verified = true THEN 1 END) as verified_count,
      COUNT(CASE WHEN discovered_date >= CURRENT_DATE - INTERVAL '30 days' THEN 1 END) as recent_count
    FROM exploits
    WHERE is_public = true
  `;

  const result = await db.query(statsQuery);
  const stats = result.rows[0];

  // Get top vulnerability categories
  const categoriesQuery = `
    SELECT 
      vc.name,
      COUNT(e.id) as count
    FROM vulnerability_categories vc
    LEFT JOIN exploits e ON vc.id = e.category_id AND e.is_public = true
    GROUP BY vc.id, vc.name
    ORDER BY count DESC
    LIMIT 10
  `;

  const categoriesResult = await db.query(categoriesQuery);

  res.json({
    overview: stats,
    top_categories: categoriesResult.rows
  });
}));

export { router as exploitRoutes };
